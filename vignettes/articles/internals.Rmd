---
title: "glitter design and internals"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(glitter)
```

The glitter package helps writing SPARQL queries by implementing an internal _domain-specific language_: with glitter, you write code that mostly looks like R code, and end up with a SPARQL query.
For instance:

```{r}
library("glitter")
query <- spq_init() %>%
  spq_add("?item wdt:P31 wd:Q13442814") %>%
  spq_add("?item rdfs:label ?itemTitle") %>%
  spq_filter(str_detect(str_to_lower(itemTitle), 'wikidata')) %>%
  spq_filter(lang(itemTitle) == "en") %>%
  spq_head(n = 5)

query
```

The R code should therefore be easier to write, and read.
The function names and syntax are meant to remind of the tidyverse, and of base R.

Code using glitter will feature:

- a call to `spq_init()`;
- most often, calls to `spq_add()` to add SPARQL triple patterns to the query;
- potentially, calls to `spq_filter()`, `spq_select()` to filter results;
- potentially, calls to `spq_arrange()`, `spq_head()`, `spq_offset()` to order and trim results;
- lastly a call to `spq_perform()` to send the query and return the results.

# glitter query object

The query object is a list with elements corresponding to e.g. the FILTER part.
Later we might make it an actual class, maybe an R6 one?

It is built by the different calls to `spq_` functions.
The SPARQL query string is assembled by `spq_assemble()`.
Later we might add some linting at that stage.

# glitter tooling

Under the hood, glitter uses

* the [rlang package by Lionel Henry and Hadley Wickham](https://rlang.r-lib.org/) to encapsulate `...` arguments into quosures before handling them. Useful references were [the Metaprogramming section of the Advanced R book by Hadley Wickham](https://adv-r.hadley.nz/metaprogramming.html) as well as the documentation of the [rlang package](https://rlang.r-lib.org/).
* the [xmlparsedata package by Gábor Csárdi](https://r-lib.github.io/xmlparsedata/) to parse the R looking code, and the [xml2 package by Hadley Wickham, Jim Hester and Jeroen Ooms](https://xml2.r-lib.org/), to transform that code into SPARQL code with XPath. Useful references were the documentation of these two packages as well as searching for XPath query examples via a search engine.
* the [httr2 package by Hadley Wickham](https://httr2.r-lib.org/) package to perform queries. We learnt sending such queries thanks to the source code of the [WikidataQueryServiceR package](https://github.com/wikimedia/WikidataQueryServiceR) by Mikhail Popov.

More details in the next sections.

# spq_add()

`spq_add()` works differently from the other `spq_` functions because it looks closer to SPARQL.

Clearly something like `spq_add(query, "?item wdt:P31 wd:Q13442814")` does not look like R code.
The motivation for this is:
- easier copy-pasting from SPARQL query examples;
- the ability to keep the SPARQL concepts.

Now, if one wants to go full DSL, it is possible, via `spq_filter()` and `spq_mutate()`.

The triple pattern in `spq_add(query, "?item wdt:P31 wd:Q13442814")` means finding items that are an instance of ("wdt:P31") of a scholarly article ("wd:Q13442814").
With glitter, you can also write it

```r
spq_init() %>%
  spq_filter(item == wdt::P31(wd::Q13442814))
```

This looks more like a normal tidyverse pipeline. Note that the namespacing here is done the R way i.e. `wdt::P31` as opposed to "wdt:P31".

